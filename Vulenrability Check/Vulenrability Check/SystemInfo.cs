using System;
using System.Globalization;
using System.Management;
using System.Net;
using System.Net.Sockets;
using System.Text.RegularExpressions;
class ClassA
{

    Singleton singleton;
    public ClassA()
    {
        singleton = Singleton.GetInstance();
    }
    internal string GetIP()
    {
        string ExternalIP = string.Empty;
        try
        {
            using (var web = new WebClient())
            {
                ServicePointManager.SecurityProtocol |= SecurityProtocolType.Ssl3;
                ServicePointManager.SecurityProtocol |= SecurityProtocolType.Tls;
                ServicePointManager.SecurityProtocol |= SecurityProtocolType.Tls11;
                ServicePointManager.SecurityProtocol |= SecurityProtocolType.Tls12;
                ExternalIP = new WebClient().DownloadString("https://jbt.clsw.kr/API/getip.php");
            }
            //ExternalIP = new WebClient().DownloadString("https://jbt.clsw.kr/API/getip.php");
            ExternalIP = ExternalIP.Substring(ExternalIP.IndexOf(":") + 2, 15); // Top IP
                                                                                //ExternalIP = ExternalIP.Substring(ExternalIP.IndexOf("<br>") + 23); 
                                                                                // Bottom IP

            ExternalIP = Regex.Match(ExternalIP, @"[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}").Value;
        }
        catch
        {
            return "Not connect";
        }
        try
        {
            IPHostEntry host = Dns.GetHostEntry(Dns.GetHostName());
            string ClusterIP = string.Empty;
            foreach (var ip in host.AddressList)
            {
                if (ip.AddressFamily == AddressFamily.InterNetwork)
                {
                    ClusterIP = ip.ToString();
                }
            }
            if (ClusterIP != String.Empty) return ExternalIP + " (" + ClusterIP + ")";
            else return ExternalIP;
        }
        catch
        {
            return "";
        }
    }
    internal string PCName()
    {
        return Environment.MachineName;
    }
    internal string OSName()
    {
        string result = "Not found!";
        ConnectionOptions options = new ConnectionOptions();
        options.Impersonation = ImpersonationLevel.Impersonate;
        ManagementScope scope = new ManagementScope("/root/cimv2", options);
        scope.Connect();
        ObjectQuery query = new ObjectQuery("Select Caption From Win32_OperatingSystem");

        ManagementObjectSearcher search = new ManagementObjectSearcher(scope, query);
        ManagementObjectCollection queryCollection = search.Get();
        foreach (ManagementObject o in queryCollection)
        {
            result = o["Caption"].ToString();
            if (Environment.Is64BitOperatingSystem)
            {
                result = result + " 64비트 ";
            }
            else
            {
                result = result + " 32비트 ";
            }
            string ver = GetOSVer();
            int len = ver.Length;
            result = result + "(" + ver.Substring(0, len - 6) + ", 빌드 " +
           ver.Substring(len - 5) + ")";
        }
        return result;
    }
    private static ManagementObject GetMngObj(string className)
    {
        var wmi = new ManagementClass(className);
        foreach (var o in wmi.GetInstances())
        {
            var mo = (ManagementObject)o;
            if (mo != null) return mo;
        }
        return null;
    }
    private string GetOSVer()
    {
        ManagementObject mo = GetMngObj("Win32_OperatingSystem");
        if (null == mo)
            return string.Empty;
        return mo["Version"] as string;
    }
    internal string GetLang()
    {
        return CultureInfo.CurrentCulture.Name.Replace("ko-KR", "한국어") + " (국가별 설정: " + CultureInfo.CurrentUICulture.Name.Replace("ko-KR", "한국어") + ")";
    }
    internal string[] SystemMaker()
    {
        string[] Maker = { null, null };
        ManagementClass mc = new ManagementClass("Win32_ComputerSystem");
        ManagementObjectCollection moc = mc.GetInstances();
        if (moc.Count != 0)
        {
            foreach (ManagementObject mo in mc.GetInstances())
            {
                Maker[0] = mo["Manufacturer"].ToString(); // 시스템 제조업체
                Maker[1] = mo["model"].ToString(); // 시스템 모델
            }
        }
        return Maker;
    }
    internal string BIOS()
    {
        string bios = null;
        ManagementObjectSearcher searcher1 = new
       ManagementObjectSearcher("SELECT * FROM Win32_BIOS");
        ManagementObjectCollection collection = searcher1.Get();
        foreach (ManagementObject obj in collection)
        {
            if (((string[])obj["BIOSVersion"]).Length > 1)
                bios = ((string[])obj["BIOSVersion"])[((string[])obj["BIOSVersion"]).Length - 2];
            else
                bios = ((string[])obj["BIOSVersion"])[0];
        }
        return bios;
    }
    internal string Processor()
    {
        string processor = null;
        ManagementObjectSearcher searcher2 = new
       ManagementObjectSearcher("Select * from Win32_Processor");
        foreach (ManagementObject process in searcher2.Get())
        {
            processor = process["Name"].ToString();
            processor += " (" + Environment.ProcessorCount + "CPUs), ~";
            double ghz = 0.001f * (uint)process["MaxClockSpeed"];
            processor += ghz.ToString("N1") + "GHz";
        }
        return processor;
    }
    internal string Memory()
    {
        string memory = null;
        while (true)
        {
            PERFORMANCE_INFORMATION pi = new PERFORMANCE_INFORMATION();
            pi.Initialize();
            SafeNativeMethods.GetPerformanceInfo(out pi, pi.cb);
            SafeNativeMethods.GetPhysicallyInstalledSystemMemory(out ulong installedMemory);
            MEMORYSTATUSEX globalMemoryStatus = new MEMORYSTATUSEX();
            globalMemoryStatus.Initialize();
            SafeNativeMethods.GlobalMemoryStatusEx(ref globalMemoryStatus);
            if (installedMemory >= 1024)
            {
                memory = $"{installedMemory / 1024} MB RAM";
                break;
            }
            else
            {
                memory = $"{installedMemory} RAM";
                break;
            }
        }    
        return memory;
    }
}
